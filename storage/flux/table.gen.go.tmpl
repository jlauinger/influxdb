package storageflux 

import (
	"sync"

	"github.com/apache/arrow/go/arrow/array"
	"github.com/influxdata/flux"
	"github.com/influxdata/flux/arrow"
	"github.com/influxdata/flux/execute"
	"github.com/influxdata/flux/memory"
	"github.com/influxdata/influxdb/v2"
	"github.com/influxdata/influxdb/v2/models"
	storage "github.com/influxdata/influxdb/v2/storage/reads"
	"github.com/influxdata/influxdb/v2/tsdb/cursors"
)
{{range .}}
//
// *********** {{.Name}} ***********
//

type {{.name}}Table struct {
	table
	mu     sync.Mutex
	cur    cursors.{{.Name}}ArrayCursor
	alloc  *memory.Allocator
}

func new{{.Name}}Table(
	done chan struct{},
	cur cursors.{{.Name}}ArrayCursor,
	bounds execute.Bounds,
	key flux.GroupKey,
	cols []flux.ColMeta,
	tags models.Tags,
	defs [][]byte,
	cache *tagsCache,
	alloc *memory.Allocator,
) *{{.name}}Table {
	t := &{{.name}}Table{
		table: newTable(done, bounds, key, cols, defs, cache, alloc),
		cur:   cur,
	}
	t.readTags(tags)
	t.advance()

	return t
}

func (t *{{.name}}Table) Close() {
	t.mu.Lock()
	if t.cur != nil {
		t.cur.Close()
		t.cur = nil
	}
	t.mu.Unlock()
}

func (t *{{.name}}Table) Statistics() cursors.CursorStats {
	t.mu.Lock()
	defer t.mu.Unlock()
	cur := t.cur
	if cur == nil {
		return cursors.CursorStats{}
	}
	cs := cur.Stats()
	return cursors.CursorStats{
		ScannedValues: cs.ScannedValues,
		ScannedBytes:  cs.ScannedBytes,
	}
}

func (t *{{.name}}Table) Do(f func(flux.ColReader) error) error {
	return t.do(f, t.advance)
}

func (t *{{.name}}Table) advance() bool {
	a := t.cur.Next()
	l := a.Len()
	if l == 0 {
		return false
	}

	// Retrieve the buffer for the data to avoid allocating
	// additional slices. If the buffer is still being used
	// because the references were retained, then we will
	// allocate a new buffer.
	cr := t.allocateBuffer(l)
	cr.cols[timeColIdx] = arrow.NewInt(a.Timestamps, t.alloc)
	cr.cols[valueColIdx] = t.toArrowBuffer(a.Values)
	t.appendTags(cr)
	t.appendBounds(cr)
	return true
}

// window table
type {{.name}}WindowTable struct {
	{{.name}}Table
	windowEvery int64
	arr         *cursors.{{.Name}}Array
	idxInArr    int
}

func new{{.Name}}WindowTable(
	done chan struct{},
	cur cursors.{{.Name}}ArrayCursor,
	bounds execute.Bounds,
	every int64,
	key flux.GroupKey,
	cols []flux.ColMeta,
	tags models.Tags,
	defs [][]byte,
	cache *tagsCache,
	alloc *memory.Allocator,
) *{{.name}}WindowTable {
	t := &{{.name}}WindowTable{
		{{.name}}Table: {{.name}}Table{
			table: newTable(done, bounds, key, cols, defs, cache, alloc),
			cur:   cur,
		},
		windowEvery: every,
	}
	t.readTags(tags)
	t.advance()

	return t
}

func (t *{{.name}}WindowTable) advance() bool {
	if t.arr == nil {
		t.arr = t.cur.Next()
		if t.arr.Len() == 0 {
			t.arr = nil
			return false
		}
		t.idxInArr = 0
	}

	// Retrieve the buffer for the data to avoid allocating
	// additional slices. If the buffer is still being used
	// because the references were retained, then we will
	// allocate a new buffer.
	columnReader := t.allocateBuffer(1)
	// regain the window start time from the window end time
	rangeStart := int64(t.bounds.Start)
	rangeEnd := int64(t.bounds.Stop)
	stop := t.arr.Timestamps[t.idxInArr]
	start := stop - t.windowEvery
	if start < rangeStart {
		start = rangeStart
	}
	if stop > rangeEnd {
		stop = rangeEnd
	}
	columnReader.cols[startColIdx] = arrow.NewInt([]int64{start}, t.alloc)
	columnReader.cols[stopColIdx] = arrow.NewInt([]int64{stop}, t.alloc)
	columnReader.cols[windowedValueColIdx] = t.toArrowBuffer(t.arr.Values[t.idxInArr : t.idxInArr+1])
	t.appendTags(columnReader)
	t.idxInArr++
	if t.idxInArr == t.arr.Len() {
		t.arr = nil
	}
	return true
}

type {{.name}}CompleteWindowTable struct {
	{{.name}}Table
	windowEvery int64
	ts          int64

	// Buffered state from the underlying cursor.
	timestamps  []int64
	values      []{{.Type}}
	i           int
	done        bool
}

func new{{.Name}}CompleteWindowTable(
		done chan struct{},
		cur cursors.{{.Name}}ArrayCursor,
		bounds execute.Bounds,
		every int64,
		key flux.GroupKey,
		cols []flux.ColMeta,
		tags models.Tags,
		defs [][]byte,
		cache *tagsCache,
		alloc *memory.Allocator,
) *{{.name}}CompleteWindowTable {
	start := int64(bounds.Start)
	t := &{{.name}}CompleteWindowTable{
		{{.name}}Table: {{.name}}Table{
			table: newTable(done, bounds, key, cols, defs, cache, alloc),
			cur:   cur,
		},
		windowEvery: every,
		ts: start + (every - start % every),
	}
	t.readTags(tags)
	t.advance()

	return t
}

// createWindows will create the next set of windows for each interval.
// The ts parameter is the first interval's stop time.
func (t *{{.name}}CompleteWindowTable) createWindows(ts int64) (next int64, start, stop *array.Int64) {
	n := int((int64(t.bounds.Stop) - ts) / t.windowEvery)
	if n > maxWindowBufferSize {
		n = maxWindowBufferSize
	}

	stopB := arrow.NewIntBuilder(t.alloc)
	stopB.Resize(n)
	for i, ts := 0, ts; i < n; i, ts = i+1, ts+t.windowEvery {
		if i == n - 1 && ts > int64(t.bounds.Stop) {
			stopB.Append(int64(t.bounds.Stop))
			continue
		}
		stopB.Append(ts)
		next = ts
	}
	stop = stopB.NewInt64Array()

	startB := arrow.NewIntBuilder(t.alloc)
	startB.Resize(n)
	for i, ts := 0, ts - t.windowEvery; i < n; i, ts = i+1, ts+t.windowEvery {
		if i == 0 && ts < int64(t.bounds.Start) {
			startB.Append(int64(t.bounds.Start))
			continue
		}
		startB.Append(ts)
	}
	start = startB.NewInt64Array()
	return next, start, stop
}

func (t *{{.name}}CompleteWindowTable) nextAt(ts int64) (v {{.Type}}, ok bool) {
	if t.i >= len(t.timestamps) && !t.nextBuffer() {
		return
	} else if t.timestamps[t.i] != ts {
		return
	}
	v, ok = t.values[t.i], true
	t.i++
	return v, ok
}

func (t *{{.name}}CompleteWindowTable) nextBuffer() bool {
	if t.done {
		return false
	}

	a := t.cur.Next()
	if a.Len() == 0 {
		t.done = true
		return false
	}
	t.timestamps = a.Timestamps
	t.values = a.Values
	t.i = 0
	return true
}

func (t *{{.name}}CompleteWindowTable) appendValues(intervals []int64, appendValue func(v {{.Type}}), appendNull func()) {
	for i := 0; i < len(intervals); i++ {
		if v, ok := t.nextAt(intervals[i]); ok {
			appendValue(v)
			continue
		}
		appendNull()
	}
}

func (t *{{.name}}CompleteWindowTable) advance() bool {
	if t.ts - t.windowEvery >= int64(t.bounds.Stop) {
		return false
	}

	var start, stop *array.Int64
	t.ts, start, stop = t.createWindows(t.ts)

	for {
		if len(t.timestamps) == 0 && !t.done {
			a := t.cur.Next()
			if a.Len() == 0 {
				t.done = true
				break
			}
		}
	}
	values := t.mergeValues(stop.Int64Values())

	// Retrieve the buffer for the data to avoid allocating
	// additional slices. If the buffer is still being used
	// because the references were retained, then we will
	// allocate a new buffer.
	cr := t.allocateBuffer(stop.Len())
	cr.cols[startColIdx] = start
	cr.cols[stopColIdx] = stop
	cr.cols[windowedValueColIdx] = values
	t.appendTags(cr)
	return true
}

// group table

type {{.name}}GroupTable struct {
	table
	mu     sync.Mutex
	gc     storage.GroupCursor
	cur    cursors.{{.Name}}ArrayCursor
}

func new{{.Name}}GroupTable(
	done chan struct{},
	gc storage.GroupCursor,
	cur cursors.{{.Name}}ArrayCursor,
	bounds execute.Bounds,
	key flux.GroupKey,
	cols []flux.ColMeta,
	tags models.Tags,
	defs [][]byte,
	cache *tagsCache,
	alloc *memory.Allocator,
) *{{.name}}GroupTable {
	t := &{{.name}}GroupTable{
		table: newTable(done, bounds, key, cols, defs, cache, alloc),
		gc:    gc,
		cur:   cur,
	}
	t.readTags(tags)
	t.advance()

	return t
}

func (t *{{.name}}GroupTable) Close() {
	t.mu.Lock()
	if t.cur != nil {
		t.cur.Close()
		t.cur = nil
	}
	if t.gc != nil {
		t.gc.Close()
		t.gc = nil
	}
	t.mu.Unlock()
}

func (t *{{.name}}GroupTable) Do(f func(flux.ColReader) error) error {
	return t.do(f, t.advance)
}

func (t *{{.name}}GroupTable) advance() bool {
RETRY:
	a := t.cur.Next()
	l := a.Len()
	if l == 0 {
		if t.advanceCursor() {
			goto RETRY
		}

		return false
	}

	// Retrieve the buffer for the data to avoid allocating
	// additional slices. If the buffer is still being used
	// because the references were retained, then we will
	// allocate a new buffer.
	cr := t.allocateBuffer(l)
	cr.cols[timeColIdx] = arrow.NewInt(a.Timestamps, t.alloc)
	cr.cols[valueColIdx] = t.toArrowBuffer(a.Values)
	t.appendTags(cr)
	t.appendBounds(cr)
	return true
}

func (t *{{.name}}GroupTable) advanceCursor() bool {
	t.cur.Close()
	t.cur = nil
	for t.gc.Next() {
		cur := t.gc.Cursor()
		if cur == nil {
			continue
		}

		if typedCur, ok := cur.(cursors.{{.Name}}ArrayCursor); !ok {
			// TODO(sgc): error or skip?
			cur.Close()
			t.err = &influxdb.Error {
				Code: influxdb.EInvalid,
				Err: &GroupCursorError {
					typ: "{{.name}}",
					cursor: cur,
				},
			}
			return false
		} else {
			t.readTags(t.gc.Tags())
			t.cur = typedCur
			return true
		}
	}
	return false
}

func (t *{{.name}}GroupTable) Statistics() cursors.CursorStats {
	if t.cur == nil {
		return cursors.CursorStats{}
	}
	cs := t.cur.Stats()
	return cursors.CursorStats{
		ScannedValues: cs.ScannedValues,
		ScannedBytes:  cs.ScannedBytes,
	}
}

{{end}}
